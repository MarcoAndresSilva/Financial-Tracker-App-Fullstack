# üèóÔ∏è Gu√≠a de Arquitectura y Construcci√≥n

Esta secci√≥n sirve como un diario de desarrollo y una gu√≠a de arquitectura detallada para el proyecto "Financial Tracker App". Documenta las decisiones clave, la estructura y los conceptos implementados en cada paso.

### **Paso 1: Configuraci√≥n del Entorno de Desarrollo con Docker**

- **Objetivo:** Crear un entorno local reproducible con Docker Compose para el backend de NestJS (`api`) y la base de datos PostgreSQL (`db`).
- **Componentes Clave:**
  - `Dockerfile`: Se utiliza un `Dockerfile` multi-etapa para construir una imagen de producci√≥n optimizada.
    - **Flujo de Build con Prisma:** Es crucial que el script `build` en `package.json` ejecute `prisma generate` _antes_ de `nest build`. Adem√°s, la etapa final `production` del Dockerfile debe copiar la carpeta `node_modules` desde la etapa `build` (no desde la de `dependencies`) para asegurar que el cliente de Prisma ya generado se incluya en la imagen final. Esto previene errores de inicializaci√≥n de Prisma en tiempo de ejecuci√≥n.
  - `docker-compose.yml`: Orquesta los servicios `api` y `db`.
    - **Comunicaci√≥n:** Los servicios se comunican a trav√©s de una red bridge personalizada, permitiendo que la API se conecte a la base de datos usando el nombre de servicio `db` como hostname.
    - **Persistencia de Datos:** Se utiliza un volumen nombrado de Docker (`pgdata`) para asegurar que los datos persistan.
    - **Variables de Entorno:** Se utiliza la directiva `env_file` para inyectar variables (como `JWT_SECRET`) desde un archivo `.env` al contenedor, y la directiva `environment` para definir o sobrescribir variables espec√≠ficas del entorno Docker (como `DATABASE_URL`).

### **Paso 2: Integraci√≥n de Prisma, Migraciones y Conexi√≥n a NestJS**

- **Objetivo:** Conectar la API a la base de datos, definir el modelo `User` inicial y crear la tabla correspondiente mediante migraciones, integrando Prisma de forma robusta en NestJS.
- **Componentes Clave:**
  - **ORM:** Se eligi√≥ Prisma por su seguridad de tipos (type-safety) y su moderna API de cliente.
  - `prisma/schema.prisma`: Es la **√∫nica fuente de verdad** para el esquema de la base de datos.
  - **Migraciones:** El comando `npx prisma migrate dev` genera y aplica migraciones SQL, manteniendo un historial versionado de los cambios del esquema.
  - **Integraci√≥n con NestJS:** Se cre√≥ un `PrismaService` y `PrismaModule` dedicados para encapsular la l√≥gica de conexi√≥n a la base de datos y hacerla disponible para inyecci√≥n de dependencias en toda la aplicaci√≥n.

### **Paso 3: M√≥dulo de Autenticaci√≥n (Registro y Login con JWT)**

- **Objetivo:** Implementar un flujo de autenticaci√≥n completo, permitiendo a los usuarios registrarse, iniciar sesi√≥n y recibir un `access_token` (JWT) para futuras peticiones.
- **Flujo de `signin` y `signup`:** Se implementaron los endpoints `POST /auth/signup` y `POST /auth/signin` siguiendo el patr√≥n de NestJS: `Controller` -> `Service` -> `DTO`. Se utiliza `bcrypt` para el hasheo y comparaci√≥n de contrase√±as, y `JwtService` para la generaci√≥n de tokens.
- **Decisiones de Arquitectura Clave:**
  - **Carga As√≠ncrona de M√≥dulos (Patr√≥n Profesional):** Para evitar "race conditions" con las variables de entorno, el `JwtModule` se registra de forma as√≠ncrona (`registerAsync`) en el `AuthModule`. Se utiliza una `useFactory` que depende del `ConfigService` para garantizar que el `JWT_SECRET` se lee solo despu√©s de que ha sido cargado por el `ConfigModule`.

### **Paso 4: Protecci√≥n de Rutas con Estrategia JWT y Guards**

- **Objetivo:** Utilizar el `access_token` para proteger rutas, implementando un endpoint de ejemplo `GET /users/me`.
- **Componentes Clave y Conceptos:**
  - **La Estrategia de Passport (`JwtStrategy`):** Una clase que encapsula la l√≥gica para validar un JWT. Extrae el token de la cabecera `Authorization`, verifica su firma y valida el payload (ej. comprobando que el usuario todav√≠a existe en la BBDD). El valor que retorna el m√©todo `validate` es inyectado por NestJS en `req.user`.
  - **El Guardi√°n (`@UseGuards(AuthGuard('jwt'))`):** Un decorador de NestJS que intercepta las peticiones y ejecuta la estrategia de autenticaci√≥n especificada. Si la estrategia tiene √©xito, permite el paso; si no, devuelve un error `401 Unauthorized`.
  - **Decorador Personalizado (`@GetUser`):** Para evitar la dependencia de Express (`@Req`) y mejorar la legibilidad, se cre√≥ un decorador personalizado. Este encapsula la l√≥gica de `request.user`, permitiendo inyectar directamente el objeto de usuario (`@GetUser() user: User`) o una de sus propiedades (`@GetUser('email') email: string`) en los controladores de forma type-safe.

### **Paso 5: Dise√±o del Esquema de Datos Multi-Cartera**

- **Objetivo:** Evolucionar el modelo de datos de un sistema de finanzas personales a uno que soporte m√∫ltiples carteras (`Wallets`) por usuario, permitiendo espacios de trabajo tanto privados como compartidos.
- **Modelo de Datos Implementado:**
  - **`Wallet`:** El n√∫cleo del sistema. Puede ser de tipo `PERSONAL` o `SHARED`.
  - **`User` y `WalletMembership`:** Se implementa una relaci√≥n **muchos-a-muchos** entre `User` y `Wallet` a trav√©s de una tabla intermedia `WalletMembership`. Esto permite que un usuario pertenezca a m√∫ltiples carteras y que una cartera tenga m√∫ltiples miembros, con roles definidos (`OWNER`, `MEMBER`).
  - **`Category` y `Subcategory`:** Ahora est√°n vinculadas directamente a una `Wallet`. Esto permite que cada cartera (personal o compartida) tenga su propio conjunto de categor√≠as personalizables.
  - **`Transaction`:** El registro de movimiento. Cada transacci√≥n est√° ligada a una `Wallet`, una `Subcategory`, y un `User` (el autor).
- **L√≥gica de Registro Actualizada (`signup`):**
  - **Requisito:** Al registrarse, un usuario debe obtener autom√°ticamente una cartera personal. Esta operaci√≥n debe ser "todo o nada" para evitar datos inconsistentes.
  - **Implementaci√≥n con Transacciones Anidadas de Prisma:** La soluci√≥n se implement√≥ usando una **escritura anidada (nested write)**. Dentro de una √∫nica operaci√≥n `prisma.user.create`, se anidan las instrucciones para crear tambi√©n la `WalletMembership` y la `Wallet` personal.
  - **Atomicidad y `ROLLBACK` (La "Pepita de Oro"):** Prisma convierte esta operaci√≥n anidada en una **transacci√≥n de base de datos** real. Si alguna de las sub-operaciones falla, toda la transacci√≥n se revierte autom√°ticamente (**`ROLLBACK`**). Esto garantiza la integridad de los datos sin necesidad de gestionar transacciones manualmente.
  - **Respuesta Enriquecida con `include`:** Se utiliza la opci√≥n `include` para que la respuesta de la creaci√≥n devuelva no solo el `User`, sino tambi√©n los datos relacionados de la `WalletMembership` y la `Wallet` que se crearon en la misma transacci√≥n.

### Paso 6: CRUD para el M√≥dulo de Categor√≠as

- **Objetivo:** Construir los endpoints para que un usuario autenticado pueda Crear, Leer, Actualizar y Borrar (CRUD) las categor√≠as dentro de una de sus carteras (`Wallets`).

- **Implementaci√≥n:**
  - **Estructura del M√≥dulo:** Se gener√≥ la estructura est√°ndar de NestJS con `CategoryModule`, `CategoryController` y `CategoryService`.
  - **DTOs (Contratos de Datos):**
    - `CreateCategoryDto`: Define los campos necesarios (`name`, `walletId`) para crear una categor√≠a, con validadores de `class-validator` como `@IsUUID`.
    - `UpdateCategoryDto`: Utiliza `PartialType` de `@nestjs/mapped-types` para crear un DTO donde todos los campos son opcionales, ideal para operaciones de actualizaci√≥n parcial (`PATCH`).
  - **Protecci√≥n de Rutas:** El `CategoryController` completo est√° protegido a nivel de clase con `@UseGuards(AuthGuard('jwt'))`, garantizando que ning√∫n usuario no autenticado pueda acceder.
  - **L√≥gica de Autorizaci√≥n (El Cerebro en el Servicio):**
    - El `CategoryService` es responsable no solo de la l√≥gica de negocio (interactuar con Prisma), sino tambi√©n de la **autorizaci√≥n** (¬øtiene este usuario permiso para hacer esto?).
    - Se cre√≥ una funci√≥n auxiliar privada `checkWalletMembership(userId, walletId, ownerRequired)`. Este m√©todo reutilizable es el n√∫cleo de la seguridad del m√≥dulo:
      1.  Verifica que el usuario (`userId` del token) es miembro de la cartera (`walletId`).
      2.  Opcionalmente, verifica si el rol de membres√≠a es `OWNER` para acciones destructivas como actualizar o eliminar.
    - Esto asegura que un usuario no pueda ver, crear o modificar categor√≠as en carteras a las que no pertenece.
  - **Pipes de Validaci√≥n de Par√°metros:** En el controlador, se utiliza `ParseUUIDPipe` en los par√°metros de ruta (`@Param`) y de query (`@Query`) para validar que los IDs tengan el formato correcto antes de que lleguen al servicio, previniendo errores de base de datos y mejorando la seguridad.

### Paso 7: CRUD para el M√≥dulo de Subcategor√≠as

- **Objetivo:** Construir los endpoints para gestionar las `Subcategories`, que est√°n anidadas dentro de una `Category`. Este m√≥dulo sirve para reforzar los patrones de dise√±o establecidos en el CRUD de Categor√≠as.
- **Implementaci√≥n:**
  - **Estructura y DTOs:** Se sigue la misma estructura que el `CategoryModule` (Controller, Service, DTOs con `PartialType` para updates).
  - **L√≥gica de Autorizaci√≥n Anidada:** La decisi√≥n de arquitectura clave aqu√≠ es c√≥mo se manejan los permisos. Para realizar cualquier operaci√≥n sobre una `Subcategory`, el servicio primero debe:
    1.  Consultar la `Subcategory` para encontrar el `id` de su `Category` padre.
    2.  Consultar la `Category` padre para encontrar el `id` de su `Wallet`.
    3.  Ejecutar la l√≥gica de `checkWalletMembership` con el `userId` del token y el `walletId` obtenido.
  - **Lecci√≥n Aprendida:** Este flujo demuestra c√≥mo la autorizaci√≥n puede propagarse a trav√©s de relaciones en el modelo de datos, asegurando que los permisos a nivel de "contenedor" (la `Wallet`) protejan todos los recursos que contiene. Se identifica la duplicaci√≥n de la funci√≥n `checkWalletMembership`, marc√°ndola como candidata a ser extra√≠da a un `PermissionsService` compartido en una futura refactorizaci√≥n para seguir el principio DRY (Don't Repeat Yourself).

### Paso 8: CRUD para el M√≥dulo de Transacciones

- **Objetivo:** Implementar la funcionalidad principal de la aplicaci√≥n: la creaci√≥n y gesti√≥n de transacciones de ingresos y gastos.
- **Implementaci√≥n:**
  - **Estructura del M√≥dulo:** Se cre√≥ la estructura est√°ndar de NestJS (`TransactionModule`, `Controller`, `Service`, `DTOs`).
  - **DTOs Detallados:** El `CreateTransactionDto` utiliza una variedad de validadores de `class-validator` (`@IsNumber`, `@IsPositive`, `@IsEnum`, `@IsDateString`) para garantizar la integridad de los datos de la transacci√≥n antes de que lleguen a la l√≥gica de negocio.
  - **L√≥gica de Autorizaci√≥n Multi-Nivel:** Este servicio presenta el caso de autorizaci√≥n m√°s complejo hasta ahora:
    1.  **Permiso de Cartera:** Al igual que en otros m√≥dulos, se verifica la membres√≠a del usuario en la `Wallet` (`checkWalletMembership`).
    2.  **Permiso de Pertenencia Cruzada:** Se a√±ade una validaci√≥n crucial para la operaci√≥n de `create` y `update`: el servicio comprueba que la `Subcategory` proporcionada pertenezca realmente a la `Wallet` especificada. Esto previene que un usuario pueda asignar una transacci√≥n en su cartera a una categor√≠a de otra cartera a la que no tiene acceso, manteniendo la integridad referencial.
    3.  **Permiso de Rol:** Las operaciones de escritura (`update`, `delete`) est√°n restringidas a usuarios con el rol `OWNER` en la cartera.
  - **Manejo de Tipos de Datos:** El servicio se encarga de transformar los datos del DTO al formato requerido por la base de datos, como convertir una `date` en formato string a un objeto `Date` de JavaScript.

### Paso 9: Endpoints del Dashboard y Datos Agregados

- **Objetivo:** Crear endpoints especializados que no devuelvan datos crudos, sino informaci√≥n procesada y agregada, lista para ser consumida por componentes de visualizaci√≥n de datos (gr√°ficos, res√∫menes) en el frontend.

#### **9.1 - Res√∫menes de Cartera (`/dashboard/summary`)**

- **Requisito:** Obtener una vista r√°pida del estado financiero de una cartera (ingresos totales, gastos totales, balance).
- **Implementaci√≥n (Prisma `aggregate`):**
  - Se implement√≥ el m√©todo `getWalletSummary` en el `DashboardService`.
  - En lugar de traer todas las transacciones y sumarlas en JavaScript, se utiliza la funci√≥n `aggregate` de Prisma. Esta delega el c√°lculo de la suma (`_sum`) directamente a la base de datos PostgreSQL, lo cual es significativamente m√°s eficiente y r√°pido.
  - Se ejecutan dos agregaciones en paralelo (una para `INCOME`, otra para `EXPENSE`) usando `Promise.all` para optimizar el tiempo de respuesta.

#### **9.2 - Gastos por Categor√≠a (`/dashboard/expenses-by-category`)**

- **Requisito:** Obtener los gastos totales agrupados por categor√≠a principal para alimentar un gr√°fico de pastel.
- **Implementaci√≥n (Prisma `groupBy` y Enriquecimiento de Datos):**
  - El servicio primero utiliza `groupBy` de Prisma para agrupar las transacciones de gastos por `subcategoryId` y sumar sus montos.
  - Como `groupBy` devuelve solo los IDs, el resultado se "enriquece" en un segundo paso: se itera sobre los grupos, se busca la informaci√≥n completa de cada subcategor√≠a (incluyendo su categor√≠a padre) y se crea un nuevo array con los nombres de las categor√≠as.
  - Finalmente, se utiliza el m√©todo `reduce` de JavaScript para sumar los montos de diferentes subcategor√≠as que pertenecen a la misma categor√≠a principal (ej. sumar "Supermercado" y "Restaurante" bajo "Comida").
  - El resultado se formatea como `{ name, value }`, un formato ideal para la mayor√≠a de las librer√≠as de gr√°ficos.

#### **9.3 - Filtrado Avanzado de Transacciones**

- **Requisito:** Permitir al usuario buscar y filtrar su lista de transacciones por m√∫ltiples criterios como rango de fechas o tipo.
- **Implementaci√≥n:**

  - **DTO para Query Params:** Se cre√≥ un `GetTransactionsFilterDto` para validar los par√°metros opcionales de la URL.
  - **Construcci√≥n Din√°mica de Consultas:** El `TransactionService` fue refactorizado para construir la cl√°usula `where` de Prisma de forma din√°mica, a√±adiendo condiciones solo si los filtros correspondientes son proporcionados.

  - **Mejora en el Backend:** Se extendi√≥ el endpoint `GET /transactions` para aceptar tambi√©n `categoryId` y `subcategoryId` como par√°metros de filtro opcionales. El `TransactionService` ahora puede filtrar transacciones por una categor√≠a espec√≠fica (incluyendo todas sus subcategor√≠as) o por una subcategor√≠a individual.

  #### **9.4 - (Implementado) Filtrado Avanzado de Transacciones en `TransactionModule`**

- Como parte de la base para el dashboard, se mejor√≥ el endpoint `GET /transactions` para aceptar filtros por `startDate`, `endDate` y `type`, permitiendo al frontend solicitar los datos precisos que necesita.

---

### **Ap√©ndice: Desaf√≠os Enfrentados y Lecciones Aprendidas**

#### **Resoluci√≥n de un Problema Persistente de "Cannot Find Module"**

Durante la creaci√≥n del decorador `@CurrentUser`, nos encontramos con un error persistente `TS2307: Cannot find module` que no se solucionaba con los m√©todos de depuraci√≥n habituales (limpieza de cach√© de npm, reinicio de VS Code).

- **Diagn√≥stico:** Se determin√≥ que la causa ra√≠z era una **cach√© corrupta del servidor de TypeScript de VS Code en el entorno WSL**. El editor no estaba reconociendo un archivo que exist√≠a f√≠sicamente en el sistema de archivos.

- **Soluci√≥n en M√∫ltiples Pasos (Proceso de "Exorcismo"):** La soluci√≥n requiri√≥ un proceso de invalidaci√≥n de cach√© a varios niveles para forzar una re-indexaci√≥n completa del proyecto:

  1.  **Recreaci√≥n de Archivos:** La acci√≥n m√°s efectiva fue eliminar por completo la carpeta y el archivo del decorador y recrearlos desde cero (incluso con un nombre ligeramente diferente, ej. `decorators`). Esto oblig√≥ al sistema de archivos a generar nuevas referencias.
  2.  **Limpieza Profunda de Dependencias:** Se realiz√≥ un ciclo completo de `rm -rf node_modules`, `rm package-lock.json`, `npm cache clean`, y `npm install` para descartar cualquier corrupci√≥n en las dependencias.
  3.  **Reinicio del Entorno Completo:** Se ejecut√≥ `wsl --shutdown` desde PowerShell para detener y reiniciar el subsistema de WSL, seguido de un reinicio de Docker Desktop.
  4.  **Ajuste Final de ESLint:** Una vez solucionado el problema de resoluci√≥n, aparecieron errores de linting (`no-unsafe-assignment`, etc.) debido a reglas muy estrictas. Estos se solucionaron desactivando dichas reglas en el archivo `eslint.config.mjs`, una pr√°ctica com√∫n para adaptar el linter a la naturaleza din√°mica de los decoradores de NestJS.

- **Lecci√≥n Aprendida:** En entornos complejos como WSL, los problemas de cach√© pueden ser profundos. Cuando el c√≥digo y la estructura son correctos pero los errores persisten, un "reseteo" completo del entorno, incluyendo la recreaci√≥n de los archivos problem√°ticos, es una estrategia de depuraci√≥n v√°lida y poderosa.

---

### **Parte 2: El Frontend (Angular)**

---

### Paso 10: Inicializaci√≥n y Configuraci√≥n del Proyecto Angular

- **Objetivo:** Crear la base para la aplicaci√≥n de frontend utilizando el Angular CLI, configurada con las mejores pr√°cticas modernas para una aplicaci√≥n de panel de control (dashboard).

- **Decisiones de Arquitectura y Configuraci√≥n:**
  - **Monorepo:** El proyecto de Angular se crea en una nueva carpeta `frontend/` en la ra√≠z del repositorio, conviviendo con la carpeta `backend/`. Esto facilita la gesti√≥n del c√≥digo y el control de versiones de toda la aplicaci√≥n.
  - **Angular CLI:** Se utiliza el comando `ng new` para generar la estructura del proyecto.
  - **Componentes Standalone (`--standalone`):** Se opt√≥ por la arquitectura moderna de Angular, que simplifica la estructura de la aplicaci√≥n al eliminar la necesidad de `NgModule`s. Los componentes, directivas y pipes ahora gestionan sus propias dependencias, lo que reduce el c√≥digo repetitivo (`boilerplate`) y mejora la optimizaci√≥n (`tree-shaking`).
  - **SCSS (`--style=scss`):** Se eligi√≥ SCSS como preprocesador de CSS para aprovechar caracter√≠sticas avanzadas como variables, mixins y anidaci√≥n, lo que permite un c√≥digo de estilos m√°s mantenible y escalable.
  - **Renderizado del Lado del Cliente (CSR):** Se opt√≥ por una configuraci√≥n de SPA (Single Page Application) tradicional. Dado que la aplicaci√≥n es una herramienta privada detr√°s de un login, el SEO no es una prioridad, y el CSR ofrece la experiencia de usuario m√°s fluida e interactiva una vez que la aplicaci√≥n ha cargado.
  - **Pivote a 100% Angular Material:**
    - **Decisi√≥n:** Tras encontrar dificultades de configuraci√≥n con Tailwind CSS en el entorno WSL, se tom√≥ la decisi√≥n arquitect√≥nica de pivotar a una estrategia de UI basada exclusivamente en **Angular Material**.
    - **Justificaci√≥n:** Este enfoque elimina la complejidad de la configuraci√≥n, garantiza una alta consistencia visual y funcional, y aprovecha el ecosistema nativo de Angular, permitiendo un desarrollo m√°s r√°pido y enfocado en la l√≥gica de negocio. La personalizaci√≥n del dise√±o se lograr√° a trav√©s de SCSS, modificando el tema de Material.
  - **Gesti√≥n de M√≥dulos de Material (Patr√≥n "Barrel"):**
    - Para evitar la importaci√≥n repetitiva de m√≥dulos de Material en cada componente standalone, se ha implementado un patr√≥n de "barrel".
    - Se cre√≥ un archivo `shared/material/material.module.ts` que no es un `NgModule`, sino un simple archivo que exporta un array constante (`MATERIAL_MODULES`) con todos los m√≥dulos de UI necesarios.
    - Los componentes que necesiten Material pueden ahora importar este array y usar el operador "spread" (`...MATERIAL_MODULES`) en su propiedad `imports`, manteniendo el c√≥digo limpio, centralizado y f√°cil de mantener.

### Paso 11: Estructura de Rutas y P√°ginas de Autenticaci√≥n

- **Objetivo:** Construir la arquitectura de enrutamiento para la secci√≥n de autenticaci√≥n y desarrollar la estructura visual inicial de la p√°gina de Login.

- **Implementaci√≥n y Decisiones Clave:**
  - **Organizaci√≥n de M√≥dulos por Funcionalidad:** Se cre√≥ una carpeta `src/app/auth/` para contener todos los artefactos relacionados con la autenticaci√≥n (componentes, rutas, servicios). Dentro de ella, se utiliza una subcarpeta `pages/` para diferenciar los componentes que act√∫an como vistas completas.
  - **Enrutamiento por M√≥dulo (`Feature Routing`):**
    - Se cre√≥ un archivo `auth.routes.ts` que define las rutas espec√≠ficas de esta funcionalidad (`login`, `register`).
    - En el archivo principal `app.routes.ts`, se utiliza **lazy loading** (`loadChildren`) para cargar estas rutas. Esta es una pr√°ctica de rendimiento crucial: el c√≥digo de las p√°ginas de autenticaci√≥n solo se descarga del servidor cuando el usuario navega a `/auth`, haciendo que la carga inicial de la aplicaci√≥n sea m√°s r√°pida.
  - **UI del Login:**
    - Se maquet√≥ la estructura visual de la p√°gina de Login utilizando componentes de **Angular Material** como `mat-card` y `mat-form-field`. Esto proporciona una base de UI accesible y funcional desde el principio.
    - Se aplicaron estilos b√°sicos con **SCSS** para centrar el formulario y asegurar una presentaci√≥n limpia, siguiendo el enfoque "funcionalidad primero, dise√±o detallado despu√©s".

### Paso 12: Conexi√≥n del Formulario de Login a la API

- **Objetivo:** Darle funcionalidad al formulario de Login, permitiendo a los usuarios autenticarse contra el backend y persistir el estado de la sesi√≥n en el navegador.

- **Implementaci√≥n y Decisiones Clave:**
  - **Formularios Reactivos (`ReactiveFormsModule`):** Se eligi√≥ el enfoque de Formularios Reactivos de Angular por su robustez y facilidad para las pruebas.
    - Se cre√≥ un `FormGroup` en el `LoginComponent` utilizando `FormBuilder`.
    - Se definieron `Validators` (`required`, `email`, etc.) directamente en el componente, creando una primera capa de validaci√≥n en el cliente que mejora la experiencia de usuario al dar feedback inmediato.
    - El estado del formulario se usa para deshabilitar din√°micamente el bot√≥n de env√≠o (`[disabled]="loginForm.invalid"`), previniendo peticiones inv√°lidas.
  - **Servicio de Abstracci√≥n de API (`AuthService`):**
    - Se cre√≥ un `AuthService` en Angular para encapsular toda la l√≥gica de comunicaci√≥n con los endpoints de autenticaci√≥n.
    - Utiliza el `HttpClient` de Angular (inyectado a trav√©s de `provideHttpClient` en `app.config.ts`) para realizar las peticiones `POST`.
    - Devuelve `Observables`, siguiendo el patr√≥n est√°ndar de programaci√≥n reactiva de Angular.
  - **Manejo del Token (JWT):**
    - El `LoginComponent` se suscribe al `Observable` del `AuthService`.
    - En caso de una respuesta exitosa, el `access_token` recibido de la API se almacena en el **`localStorage`** del navegador.
    - **Justificaci√≥n de `localStorage`:** A diferencia de la base de datos (que vive en el servidor), `localStorage` es un almacenamiento persistente en el navegador del cliente. Es el lugar est√°ndar para guardar el token JWT, permitiendo que la aplicaci√≥n recuerde que el usuario est√° autenticado incluso si refresca la p√°gina o cierra y vuelve a abrir el navegador.

### Paso 13: Mecanismos de Sesi√≥n y Protecci√≥n de Rutas (Interceptor y Guard)

- **Objetivo:** Automatizar el uso del token JWT guardado y proteger las √°reas privadas de la aplicaci√≥n, asegurando que solo los usuarios autenticados puedan acceder a ellas.

#### **13.1 - Interceptor HTTP para Autenticaci√≥n**

- **Concepto:** Un `HttpInterceptor` en Angular es una funci√≥n que se sit√∫a en medio de todas las peticiones HTTP salientes para modificarlas.
- **Implementaci√≥n (`auth.interceptor.ts`):** Se cre√≥ un interceptor funcional que busca el `access_token` en `localStorage`. Si existe, clona la petici√≥n y le a√±ade la cabecera `Authorization: Bearer <token>`. Se registra globalmente en `app.config.ts` para automatizar la autenticaci√≥n de todas las llamadas a la API.

#### **13.2 - Route Guard para Autorizaci√≥n de Vistas**

- **Concepto:** Un `Guard` en el enrutador de Angular es una funci√≥n que se ejecuta antes de permitir la navegaci√≥n a una ruta, devolviendo `true` (permitir) o `false` (bloquear).
- **Implementaci√≥n (`auth.guard.ts`):** Se cre√≥ un `CanActivateFn` que comprueba la existencia del `access_token` en `localStorage`. Si el token no existe, cancela la navegaci√≥n y redirige al usuario a la p√°gina de `/auth/login`.
- **Aplicaci√≥n:** El guardi√°n se aplica a las rutas principales que necesitan protecci√≥n en `app.routes.ts` utilizando la propiedad `canActivate: [authGuard]`.

#### **13.3 - Desaf√≠os Enfrentados y Soluciones**

- **Problema de Redirecci√≥n:** Se detect√≥ un bug donde la redirecci√≥n al dashboard fallaba porque el `AuthGuard` buscaba el token con una clave incorrecta en `localStorage` (`'token'` en lugar de `'access_token'`).
- **Soluci√≥n:** Se estandariz√≥ el uso de la clave `'access_token'` en toda la aplicaci√≥n (tanto en el `AuthService` que lo guarda como en el `AuthGuard` que lo lee), solucionando el flujo de redirecci√≥n.

### Paso 14: Construcci√≥n de la P√°gina Principal del Dashboard

- **Objetivo:** Crear la primera vista funcional para el usuario autenticado, mostrando un resumen de su cartera y una visualizaci√≥n gr√°fica de sus gastos.

- **Implementaci√≥n y Decisiones Clave:**

  - **Servicio de Datos del Dashboard:** Se cre√≥ un `DashboardService` en Angular, dedicado a comunicarse con los endpoints `/dashboard/*` del backend. Este servicio encapsula las llamadas HTTP para obtener datos agregados, como el resumen de la cartera y los gastos por categor√≠a.
  - **Componente Contenedor (`HomeComponent`):** Este componente act√∫a como el "cerebro" de la p√°gina. En su `ngOnInit`, orquesta las llamadas al `DashboardService` para obtener los datos necesarios.
  - **Visualizaci√≥n de Datos:**
    - Los datos de resumen (ingresos, gastos, balance) se muestran en tarjetas (`mat-card`) para una lectura r√°pida.
    - Se utiliza el **`currency` pipe** de Angular para formatear los valores num√©ricos como moneda local, mejorando la presentaci√≥n y la experiencia de usuario.
  - **Integraci√≥n de Gr√°ficos con `ngx-charts`:**

    - Se eligi√≥ `ngx-charts` como librer√≠a de visualizaci√≥n por su buena integraci√≥n con Angular y su facilidad de uso.
    - Se implement√≥ un gr√°fico de dona (`ngx-charts-pie-chart`) en la plantilla del `HomeComponent`.
    - La propiedad `[results]` del componente del gr√°fico se enlaza directamente al array de datos `expensesByCategory` que viene de la API, demostrando un flujo de datos reactivo y eficiente desde el backend hasta la UI.

    #### **14.1 - Depuraci√≥n y Tipado Fuerte en Plantillas**

- **Desaf√≠o:** Durante la implementaci√≥n del gr√°fico, surgieron errores de TypeScript en la plantilla HTML, como `Type '"below"' is not assignable to type 'LegendPosition'`.
- **Soluci√≥n y Buena Pr√°ctica:** Se resolvi√≥ importando el `enum` `LegendPosition` de `@swimlane/ngx-charts` directamente en el archivo TypeScript del componente (`home.component.ts`) y creando una propiedad de clase para almacenar el valor deseado (ej. `legendPosition: LegendPosition = LegendPosition.Below;`).
- **Lecci√≥n Aprendida:** Cuando se utiliza el _binding de propiedad_ (`[prop]="value"`), Angular eval√∫a `value` como una expresi√≥n de TypeScript. Para tipos complejos como los `enums`, la mejor pr√°ctica es manejar el valor en el TypeScript del componente y enlazar la propiedad de la plantilla a esa variable de componente. Esto aprovecha al m√°ximo la seguridad de tipos, permite el autocompletado en el editor y mantiene la plantilla m√°s limpia.

### Paso 15: Implementaci√≥n del Layout Principal de la Aplicaci√≥n

- **Objetivo:** Crear una estructura de navegaci√≥n persistente (shell) para todas las vistas autenticadas, utilizando un men√∫ lateral (sidenav) y una barra de herramientas superior (toolbar).

- **Implementaci√≥n y Decisiones Clave:**
  - **Componente de Layout (`DashboardLayoutComponent`):** Se cre√≥ un componente dedicado para actuar como el "esqueleto" de la aplicaci√≥n. Este componente no contiene l√≥gica de negocio, solo la estructura visual.
  - **Uso de Componentes de `Angular Material`:**
    - `MatSidenavContainer`, `MatSidenav` y `MatSidenavContent`: Se utilizaron para crear un layout robusto de navegaci√≥n lateral. El `mode="side"` asegura que el contenido principal se ajuste cuando el men√∫ se muestra u oculta.
    - `MatToolbar`: Proporciona una barra de herramientas superior est√°ndar. Incluye un bot√≥n que interact√∫a con el `MatSidenav` (`sidenav.toggle()`) para controlar su visibilidad.
    - `MatNavList` y `mat-list-item`: Se usan para crear una lista de navegaci√≥n sem√°nticamente correcta dentro del sidenav.
  - **Arquitectura de Enrutamiento Padre-Hijo:**
    - La configuraci√≥n de rutas del dashboard (`dashboard.routes.ts`) se refactoriz√≥ para adoptar un patr√≥n de anidamiento.
    - La ruta padre (`path: ''`) ahora renderiza el `DashboardLayoutComponent`.
    - Las p√°ginas reales (como `HomeComponent`) se definen como rutas `children`. Estas se renderizan dentro del `<router-outlet>` del `DashboardLayoutComponent`.
    - **Beneficio:** Esta arquitectura asegura que el layout (header, sidenav) se renderice una sola vez y persista a trav√©s de la navegaci√≥n entre las diferentes secciones del dashboard, creando una experiencia de usuario fluida y de aplicaci√≥n de una sola p√°gina (SPA).
  - **Enlaces de Ruta Activos (`routerLinkActive`):** Se utiliza la directiva `routerLinkActive` en los enlaces del men√∫. Angular a√±ade autom√°ticamente una clase CSS (`active-link`) al enlace correspondiente a la ruta activa, permiti√©ndonos resaltar visualmente la secci√≥n actual en la que se encuentra el usuario.

### Paso 16: Implementaci√≥n de la Vista de Lista de Transacciones

- **Objetivo:** Crear una vista detallada y funcional donde el usuario pueda ver todas sus transacciones, sentando las bases para la interacci√≥n principal con la aplicaci√≥n.

- **Implementaci√≥n y Decisiones Clave:**
  - **Componente Dedicado (`TransactionListComponent`):** Se gener√≥ un nuevo componente de p√°gina dentro del `DashboardModule` para encapsular toda la l√≥gica y la vista de la lista de transacciones.
  - **Servicio de Datos (`TransactionService` Angular):** Se cre√≥ un servicio en una carpeta de dominio `transactions/` para manejar la comunicaci√≥n con la API de transacciones del backend. Esto separa la l√≥gica de obtenci√≥n de datos de la l√≥gica de presentaci√≥n, siguiendo el principio de responsabilidad √∫nica.
  - **Indicador de Carga (Spinner Reutilizable):**
    - Se cre√≥ un `LoadingSpinnerComponent` gen√©rico en la carpeta `shared/components`.
    - En la `TransactionListComponent`, se implement√≥ una propiedad `isLoading` que se activa antes de la llamada a la API y se desactiva en el bloque `finalize` del observable de RxJS. Esto asegura que el spinner se oculte tanto si la petici√≥n tiene √©xito como si falla.
    - La plantilla utiliza `*ngIf` para mostrar condicionalmente el spinner o la lista de resultados, mejorando la experiencia de usuario (UX) durante la carga de datos.
  - **Dise√±o de la Lista (Tarjeta de Transacci√≥n):**
    - **Decisi√≥n Arquitect√≥nica:** En lugar de usar `mat-table`, que es dif√≠cil de hacer responsive, se opt√≥ por un enfoque "Mobile-First" utilizando `div`s con `display: flex`. Se abandon√≥ el uso de `mat-list` para tener un control total y expl√≠cito sobre el layout.
    - **Maquetaci√≥n:** Cada transacci√≥n se representa como una tarjeta individual con un layout horizontal claro: [Icono] [Descripci√≥n/Detalles] [Monto].
    - **Estilos Din√°micos:** Se utiliza la directiva `[ngClass]` para aplicar clases CSS condicionales, cambiando el color del icono y del monto dependiendo de si la transacci√≥n es un `INCOME` (verde) o un `EXPENSE` (rojo).
    - **Pipes de Angular:** Se usan los pipes `date` y `currency` para formatear los datos directamente en la plantilla, manteniendo la l√≥gica de presentaci√≥n fuera del componente TypeScript.
  - **Bot√≥n Flotante de Acci√≥n (FAB):** Se a√±adi√≥ un `mat-fab` para la acci√≥n principal de la p√°gina (a√±adir una nueva transacci√≥n), siguiendo las gu√≠as de dise√±o de Material para acciones primarias en una vista.

### Paso 17: Implementaci√≥n de la Vista de Lista de Transacciones y Filtros Avanzados

- **Objetivo:** Construir la vista principal para la gesti√≥n de transacciones, mostrando una lista de movimientos y proporcionando una interfaz de usuario robusta para filtrarlos din√°micamente.

- **Implementaci√≥n y Decisiones Clave:**
  - **Componente y Servicio Dedicados:** Se sigui√≥ el patr√≥n establecido, creando un `TransactionListComponent` para la vista y un `TransactionService` en Angular para encapsular la l√≥gica de API, manteniendo una clara separaci√≥n de responsabilidades.
  - **Carga Inicial de Datos:** En el `ngOnInit`, se realiza una llamada inicial a `loadTransactions()` para poblar la vista con todos los datos disponibles tan pronto como el componente se carga, proporcionando valor inmediato al usuario.
  - **Formulario de Filtros Reactivo (`filterForm`):**
    - Se implement√≥ un `FormGroup` para gestionar el estado de todos los controles de filtro (`type`, `startDate`, `endDate`, `categoryId`, `subcategoryId`).
    - Este enfoque centraliza el estado de los filtros y facilita la interacci√≥n con ellos de forma reactiva.
  - **L√≥gica de Filtros Din√°micos y Dependientes (RxJS):**
    - **Filtros Independientes:** La recarga de transacciones se dispara escuchando el `valueChanges` del `filterForm` completo. Para optimizar el rendimiento y la UX, se utilizan operadores de RxJS:
      - `debounceTime(400)`: Evita hacer llamadas a la API con cada pulsaci√≥n de tecla o cambio r√°pido, esperando a que el usuario haga una pausa.
      - `distinctUntilChanged()`: Previene llamadas duplicadas si el valor de los filtros no ha cambiado realmente.
    - **Filtros Dependientes (Categor√≠a -> Subcategor√≠a):** Se implement√≥ una l√≥gica reactiva separada para los filtros anidados.
      - Se suscribe a los `valueChanges` del control de `categoryId`.
      - Utiliza el operador `switchMap` para cancelar peticiones anteriores y lanzar una nueva llamada al `SubcategoryService` cada vez que se selecciona una nueva categor√≠a.
      - Esto asegura que el desplegable de subcategor√≠as siempre muestre opciones relevantes y se actualice de forma eficiente.
  - **Manejo de Fechas (Localizaci√≥n vs. API):**
    - **UI:** Se configur√≥ la localizaci√≥n de Angular (`LOCALE_ID`) y Angular Material (`MAT_DATE_LOCALE`) a `'es-CL'`. Esto hace que el `mat-date-range-input` muestre y acepte fechas en el formato `DD/MM/YYYY`, familiar para el usuario.
    - **L√≥gica de Env√≠o:** En el componente, antes de enviar los filtros a la API, la funci√≥n `formatDate` de Angular se utiliza para convertir las fechas al formato est√°ndar ISO (`YYYY-MM-DD`), que es el que el backend espera. Esta transformaci√≥n garantiza una comunicaci√≥n robusta y sin ambig√ºedades con el servidor.

### Paso 18: Creaci√≥n de Transacciones desde el Frontend

- **Objetivo:** Permitir al usuario a√±adir nuevas transacciones a trav√©s de una interfaz de usuario intuitiva y fluida, completando el ciclo CRUD principal de la aplicaci√≥n.

- **Implementaci√≥n y Decisiones Clave:**
  - **Experiencia de Usuario con Di√°logo Modal (`MatDialog`):**
    - **Decisi√≥n:** En lugar de navegar a una nueva p√°gina, la creaci√≥n de transacciones se maneja a trav√©s de un **di√°logo modal**.
    - **Justificaci√≥n:** Esta elecci√≥n proporciona una UX superior, ya que el usuario no pierde el contexto de la lista de transacciones que est√° viendo. La acci√≥n de "a√±adir" se siente como una tarea r√°pida y superpuesta.
  - **Componente de Formulario Reutilizable (`TransactionFormComponent`):**
    - Se cre√≥ un componente dedicado exclusivamente para el formulario. Esto sigue el principio de responsabilidad √∫nica y permite que el mismo formulario pueda ser reutilizado en el futuro para una funcionalidad de "editar transacci√≥n".
  - **Paso de Datos a Di√°logos (`MAT_DIALOG_DATA`):** Se utiliza el token de inyecci√≥n `MAT_DIALOG_DATA` para pasar informaci√≥n esencial (como el `walletId` actual) desde el componente padre (`TransactionListComponent`) al componente hijo dentro del di√°logo (`TransactionFormComponent`).
  - **Comunicaci√≥n de Vuelta y Refresco de Datos:**
    - El `TransactionFormComponent` utiliza `MatDialogRef` para controlar su propio estado. Al guardar una transacci√≥n con √©xito, llama a `dialogRef.close(true)`.
    - El `TransactionListComponent` se suscribe al evento `afterClosed()` del di√°logo. Si recibe el valor `true`, interpreta que la operaci√≥n fue exitosa y vuelve a llamar a su m√©todo `loadTransactions()`.
    - Este patr√≥n de **"abrir -> actuar -> cerrar con resultado -> reaccionar"** es el est√°ndar para manejar la comunicaci√≥n y el refresco de datos con di√°logos en Angular.

---

#### ** - Desaf√≠os Enfrentados Durante la Conexi√≥n Frontend-Backend**

- **Problema 1: Error `NG01101 (Expected async validator)`:**

  - **S√≠ntoma:** La aplicaci√≥n fallaba al escribir en el campo de contrase√±a.
  - **Causa:** Una ambig√ºedad en la forma en que `FormBuilder` interpreta los arrays de validadores.
  - **Soluci√≥n:** Se refactoriz√≥ la creaci√≥n del `FormGroup` para usar `new FormControl()` expl√≠citamente para cada campo. Esto elimina cualquier ambig√ºedad para el motor de formularios de Angular, especificando claramente que solo se est√°n usando validadores s√≠ncronos.

- **Problema 2: Error de CORS (`HttpErrorResponse status: 0`):**

  - **S√≠ntoma:** Las peticiones desde Angular fallaban con un error de "conexi√≥n rechazada" o "error desconocido".
  - **Causa:** La pol√≠tica de seguridad "Same-origin" del navegador, que impide que un origen (`http://localhost:4200`) haga peticiones a otro (`http://localhost:3000`) sin permiso expl√≠cito.
  - **Soluci√≥n:** Se habilit√≥ CORS en el backend de NestJS. En `main.ts`, se a√±adi√≥ `app.enableCors()`, especificando el `origin` exacto del frontend de Angular. Esto le indica al servidor que conf√≠e y acepte las peticiones que vienen de nuestra aplicaci√≥n cliente.

- **Problema 3: Error `404 Not Found` en el Login:**
  - **S√≠ntoma:** Despu√©s de solucionar CORS, la petici√≥n de login recib√≠a un error 404.
  - **Causa:** Una inconsistencia de nombres. El endpoint en el backend era `/auth/signin`, pero el `AuthService` de Angular estaba llamando a `/auth/login`.
  - **Soluci√≥n:** Se alinearon los nombres, actualizando la ruta en el `AuthService` de Angular para que coincidiera con la ruta definida en el `AuthController` de NestJS.
